package io.github.isoteriktech.xgdx.physics2d.colliders;

import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.FixtureDef;
import com.badlogic.gdx.physics.box2d.Shape;
import io.github.isoteriktech.xgdx.Component;
import io.github.isoteriktech.xgdx.physics2d.PhysicsMaterial2d;

/**
 * A collider generates a {@link com.badlogic.gdx.physics.box2d.Shape} used for collision detection.
 * <strong>Note:</strong> collision {@link com.badlogic.gdx.physics.box2d.Shape}s are disposed automatically after use.
 * Colliders use {@link io.github.isoteriktech.xgdx.physics2d.PhysicsMaterial2d} to define their physical properties.
 *
 * @author isoteriksoftware
 */
public abstract class Collider extends Component {
    /**
     * The physics material for this collider
     */
    protected PhysicsMaterial2d material;

    /**
     * The fixture generated by this collider.
     */
    protected Fixture fixture;

    /**
     * Determines if this collider is a sensor.
     */
    protected boolean isSensor;

    /**
     * The shape generated by this collider.
     */
    protected Shape shape;

    /**
     * The user data for this collider.
     */
    protected Object userData;

    protected short groupIndex = 0;
    protected short categoryBits = 0x0001;
    protected short maskBits = -1;

    /**
     * Sets the physics material for this collider.
     * <strong>Note:</strong> this has no effect if the collider has already been used by a {@link io.github.isoteriktech.xgdx.physics2d.RigidBody2d}
     * @param material the physics material
     * @return the collider for chaining
     */
    public Collider setMaterial(PhysicsMaterial2d material) {
        this.material = material;
        return this;
    }

    /**
     * Returns the physics material.
     * @return the physics material.
     */
    public PhysicsMaterial2d getMaterial() {
        return material;
    }

    /**
     * Determines if this collider is a sensor. A sensor collider collects contact information but never generates a collision response!
     * @param isSensor whether this collider is a sensor.
     */
    public void setIsSensor(boolean isSensor)
    { this.isSensor = isSensor; }

    /**
     *
     * @return whether this collider is a sensor
     */
    public boolean isSensor()
    { return isSensor; }

    /**
     * Sets the user data for the fixture generated by this collider.
     * <strong>Note:</strong> This method can be called even after the fixture is generated.
     * @param userData the user data.
     */
    public void setUserData(Object userData) {
        this.userData = userData;
        if (fixture != null)
            fixture.setUserData(userData);
    }

    /**
     * Returns the user data for the fixture generated by this collider.
     * @return the user data for the fixture generated by this collider.
     */
    public Object getUserData() {
        return userData;
    }

    /**
     *
     * @return the collision group index
     */
    public short getGroupIndex()
    { return groupIndex; }

    /**
     * Sets the collision group index for this collider.
     * Collision groups allow a certain group of objects to never collide (negative) or always collide (positive). Zero means no
     * collision group. Non-zero group filtering always wins against the mask bits.
     * @param groupIndex the collision group index
     */
    public void setGroupIndex(short groupIndex)
    { this.groupIndex = groupIndex; }

    /**
     *
     * @return the collision category bits
     */
    public short getCategoryBits()
    { return categoryBits; }

    /**
     * Sets the collision category bits. Normally you would just set one bit.
     * @param categoryBits the collision category bits
     */
    public void setCategoryBits(short categoryBits)
    { this.categoryBits = categoryBits; }

    /**
     *
     * @return the collision mask bits.
     */
    public short getMaskBits()
    { return maskBits; }

    /**
     * Sets the collision mask bits. This states the categories that the generated shape would accept for collision.
     * @param maskBits the collision mask bits.
     */
    public void setMaskBits(short maskBits)
    { this.maskBits = maskBits; }

    /**
     * Sets the {@link Fixture} generated for this collider.
     * This is called internally by the system and should never be called
     * @param fixture the fixture
     */
    public void __setFixture(Fixture fixture)
    { this.fixture = fixture; }

    /**
     *
     * @return the {@link Fixture} that this collider generates
     */
    public Fixture getFixture()
    { return fixture; }

    /**
     * Returns the shape generated by this collider.
     * @return the shape generated by this collider.
     */
    public Shape getShape() {
        return shape;
    }

    /**
     * Disposes the {@link Shape} used by this collider.
     * This is called internally by the system and should never be called
     */
    public void __disposeShape()
    {
        if (shape != null)
            shape.dispose();
    }

    /**
     * Creates a {@link FixtureDef} for this collider and return it.
     * null can be returned if it's not possible to create the fixture
     * Concrete subclasses must implement this method
     * @return a {@link FixtureDef} for this collider
     */
    public abstract FixtureDef __getFixtureDef();
}